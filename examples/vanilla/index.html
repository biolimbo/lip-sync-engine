<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LipSyncEngine.js - Vanilla JavaScript (CDN)</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #0f0f0f;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      background: #1a1a1a;
      border-radius: 16px;
      padding: 40px;
      max-width: 900px;
      width: 100%;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      border: 1px solid #2a2a2a;
    }

    h1 {
      color: #ffffff;
      margin-bottom: 8px;
      font-size: 2em;
      font-weight: 700;
    }

    .subtitle {
      color: #888;
      margin-bottom: 32px;
      font-size: 0.95em;
    }

    .input-group {
      margin-bottom: 24px;
    }

    label {
      display: block;
      color: #b0b0b0;
      font-weight: 500;
      margin-bottom: 8px;
      font-size: 0.9em;
    }

    input[type="text"] {
      width: 100%;
      padding: 12px 16px;
      background: #0f0f0f;
      border: 1px solid #333;
      border-radius: 8px;
      color: #e0e0e0;
      font-size: 15px;
      transition: border-color 0.2s, background 0.2s;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #4a9eff;
      background: #141414;
    }

    .controls {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }

    button {
      background: #4a9eff;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      flex: 1;
      min-width: 140px;
    }

    button:hover:not(:disabled) {
      background: #3a8eef;
      transform: translateY(-1px);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
    }

    button:disabled {
      background: #2a2a2a;
      color: #666;
      cursor: not-allowed;
    }

    .status {
      background: #0f0f0f;
      padding: 14px 18px;
      border-radius: 8px;
      margin-bottom: 24px;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 13px;
      color: #888;
      border: 1px solid #2a2a2a;
    }

    .status.recording {
      background: #2a1a1a;
      color: #ff6b6b;
      border-color: #4a2a2a;
    }

    .status.analyzing {
      background: #1a2330;
      color: #4a9eff;
      border-color: #2a3a4a;
    }

    .status.success {
      background: #1a2a1a;
      color: #51cf66;
      border-color: #2a4a2a;
    }

    .viseme-display {
      background: #0f0f0f;
      border-radius: 12px;
      padding: 40px;
      margin-bottom: 24px;
      border: 1px solid #2a2a2a;
      position: relative;
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .viseme-images {
      position: relative;
      width: 200px;
      height: 200px;
    }

    .viseme-images img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      object-fit: contain;
    }

    .viseme-images img.active {
      opacity: 1;
    }

    .viseme-label {
      text-align: center;
      margin-top: 16px;
      font-size: 14px;
      color: #888;
      font-weight: 500;
    }

    .results {
      background: #0f0f0f;
      border-radius: 12px;
      padding: 24px;
      border: 1px solid #2a2a2a;
    }

    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .results h3 {
      color: #ffffff;
      font-size: 1.1em;
      font-weight: 600;
      margin: 0;
    }

    .play-btn {
      background: #51cf66;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      min-width: auto;
      flex: none;
    }

    .play-btn:hover:not(:disabled) {
      background: #40c057;
      transform: translateY(-1px);
    }

    .play-btn:disabled {
      background: #2a2a2a;
      color: #666;
      cursor: not-allowed;
    }

    .cues-list {
      max-height: 300px;
      overflow-y: auto;
    }

    .cues-list::-webkit-scrollbar {
      width: 8px;
    }

    .cues-list::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 4px;
    }

    .cues-list::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 4px;
    }

    .cues-list::-webkit-scrollbar-thumb:hover {
      background: #444;
    }

    .cue {
      background: #1a1a1a;
      padding: 12px 16px;
      border-radius: 6px;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-left: 3px solid #4a9eff;
    }

    .cue-time {
      color: #888;
      font-size: 13px;
      font-family: 'SF Mono', Monaco, monospace;
    }

    .cue-value {
      font-weight: 700;
      color: #4a9eff;
      font-size: 18px;
      font-family: 'SF Mono', Monaco, monospace;
    }

    .error {
      background: #2a1a1a;
      color: #ff6b6b;
      padding: 14px 18px;
      border-radius: 8px;
      margin-top: 16px;
      border: 1px solid #4a2a2a;
      font-size: 14px;
    }

    .logs {
      margin-top: 32px;
    }

    .logs-content {
      background: #0f0f0f;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 15px;
      margin-top: 16px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.5;
      color: #888;
    }

    .log-entry.info {
      color: #4a9eff;
    }

    .log-entry.error {
      color: #ff6b6b;
    }

    .log-entry.warn {
      color: #ffd43b;
    }

    .log-entry.success {
      color: #51cf66;
    }

    .logs-content::-webkit-scrollbar {
      width: 8px;
    }

    .logs-content::-webkit-scrollbar-track {
      background: #000;
      border-radius: 4px;
    }

    .logs-content::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 4px;
    }

    .logs-content::-webkit-scrollbar-thumb:hover {
      background: #444;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé§ LipSyncEngine.js</h1>
    <p class="subtitle">Vanilla JavaScript Example (CDN)</p>

    <div class="input-group">
      <label for="dialogText">Dialog Text (Optional - improves accuracy)</label>
      <input
        type="text"
        id="dialogText"
        placeholder="Enter the text that will be spoken..."
      >
    </div>

    <div class="controls">
      <button id="recordBtn">üéôÔ∏è Record Audio (5s)</button>
      <button id="loadBtn">üìÅ Load Audio File</button>
      <input type="file" id="fileInput" accept="audio/*" style="display: none;">
    </div>

    <div id="status" class="status">Initializing LipSyncEngineEngine...</div>

    <div id="visemeDisplay" class="viseme-display">
      <div>
        <div class="viseme-images" id="visemeImages">
          <img src="../assets/visemes/X.png" alt="X" data-viseme="X">
          <img src="../assets/visemes/A.png" alt="A" data-viseme="A">
          <img src="../assets/visemes/B.png" alt="B" data-viseme="B">
          <img src="../assets/visemes/C.png" alt="C" data-viseme="C">
          <img src="../assets/visemes/D.png" alt="D" data-viseme="D">
          <img src="../assets/visemes/E.png" alt="E" data-viseme="E">
          <img src="../assets/visemes/F.png" alt="F" data-viseme="F">
          <img src="../assets/visemes/G.png" alt="G" data-viseme="G">
          <img src="../assets/visemes/H.png" alt="H" data-viseme="H">
        </div>
        <div class="viseme-label" id="visemeLabel">Closed/Rest (X)</div>
      </div>
    </div>

    <div id="results" class="results" style="display: none;">
      <div class="results-header">
        <h3>Lip Sync Results</h3>
        <button id="playBtn" class="play-btn">‚ñ∂ Play</button>
      </div>
      <div id="cuesList" class="cues-list"></div>
    </div>

    <div id="error" class="error" style="display: none;"></div>

    <div class="logs">
      <h3>Logs</h3>
      <div id="logsContent" class="logs-content"></div>
    </div>
  </div>

  <script type="module">
    // Import from unpkg.com CDN
    import { LipSyncEngine, recordAudio, loadAudio } from 'https://unpkg.com/lip-sync-engine@latest/dist/index.mjs';

    const recordBtn = document.getElementById('recordBtn');
    const loadBtn = document.getElementById('loadBtn');
    const playBtn = document.getElementById('playBtn');
    const fileInput = document.getElementById('fileInput');
    const dialogTextInput = document.getElementById('dialogText');
    const statusEl = document.getElementById('status');
    const resultsEl = document.getElementById('results');
    const cuesListEl = document.getElementById('cuesList');
    const errorEl = document.getElementById('error');
    const visemeDisplayEl = document.getElementById('visemeDisplay');
    const visemeImagesEl = document.getElementById('visemeImages');
    const visemeLabelEl = document.getElementById('visemeLabel');
    const logsContentEl = document.getElementById('logsContent');

    const visemeNames = {
      X: 'Closed/Rest',
      A: 'Open',
      B: 'Lips Together',
      C: 'Rounded',
      D: 'Tongue-Teeth',
      E: 'Slightly Open',
      F: 'F/V Sound',
      G: 'Open Back',
      H: 'Wide Open'
    };

    let lipSyncEngine = null;
    let currentPlayback = null;
    let lastResult = null;
    let lastAudioBuffer = null;

    // Intercept console logs to display in UI
    const originalConsoleLog = console.log;
    const originalConsoleError = console.error;
    const originalConsoleWarn = console.warn;

    function getTimestamp() {
      const now = new Date();
      const hours = now.getHours().toString().padStart(2, '0');
      const minutes = now.getMinutes().toString().padStart(2, '0');
      const seconds = now.getSeconds().toString().padStart(2, '0');
      const ampm = hours >= 12 ? 'PM' : 'AM';
      const displayHours = hours % 12 || 12;
      return `[${displayHours}:${minutes}:${seconds} ${ampm}]`;
    }

    function addLog(message, type = 'info') {
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry ${type}`;
      logEntry.textContent = `${getTimestamp()} ${message}`;
      logsContentEl.appendChild(logEntry);
      logsContentEl.scrollTop = logsContentEl.scrollHeight;
    }

    console.log = function(...args) {
      originalConsoleLog.apply(console, args);
      addLog(args.join(' '), 'info');
    };

    console.error = function(...args) {
      originalConsoleError.apply(console, args);
      addLog(args.join(' '), 'error');
    };

    console.warn = function(...args) {
      originalConsoleWarn.apply(console, args);
      addLog(args.join(' '), 'warn');
    };

    // Set initial viseme
    function setViseme(viseme) {
      const images = visemeImagesEl.querySelectorAll('img');
      images.forEach(img => {
        img.classList.toggle('active', img.dataset.viseme === viseme);
      });
      visemeLabelEl.textContent = `${visemeNames[viseme]} (${viseme})`;
    }

    // Initialize with X viseme
    setViseme('X');

    // Initialize LipSyncEngine
    async function init() {
      try {
        addLog('Initializing LipSyncEngine WASM module...', 'info');
        lipSyncEngine = LipSyncEngine.getInstance();
        await lipSyncEngine.init({
          wasmPath: 'https://unpkg.com/lip-sync-engine@latest/dist/wasm/lip-sync-engine.wasm',
          dataPath: 'https://unpkg.com/lip-sync-engine@latest/dist/wasm/lip-sync-engine.data',
          jsPath: 'https://unpkg.com/lip-sync-engine@latest/dist/wasm/lip-sync-engine.js'
        });
        addLog('‚úÖ WASM module loaded successfully', 'success');
        addLog('Viseme images preloaded', 'info');
        statusEl.textContent = 'Ready to analyze audio';
        statusEl.className = 'status';
        recordBtn.disabled = false;
        loadBtn.disabled = false;
      } catch (err) {
        showError('Failed to initialize LipSyncEngine: ' + err.message);
      }
    }

    // Analyze audio
    async function analyze(pcm16, audioBuffer) {
      try {
        statusEl.textContent = 'Analyzing audio...';
        statusEl.className = 'status analyzing';

        addLog('=== Starting Analysis ===', 'info');
        const dialogText = dialogTextInput.value.trim();
        const duration = (pcm16.length / 16000).toFixed(2);
        addLog(`Analyzing ${pcm16.length} samples (${duration}s at 16kHz)${dialogText ? ' with dialog text' : ''}`, 'info');

        const result = await lipSyncEngine.analyze(pcm16, {
          dialogText: dialogText || undefined,
          sampleRate: 16000
        });

        addLog(`‚úÖ Analysis complete! Found ${result.mouthCues.length} mouth cues`, 'success');
        displayResults(result, audioBuffer);
        statusEl.textContent = `Analysis complete! Found ${result.mouthCues.length} mouth cues`;
        statusEl.className = 'status success';
      } catch (err) {
        showError('Analysis failed: ' + err.message);
        statusEl.textContent = 'Analysis failed';
        statusEl.className = 'status';
      }
    }

    // Display results
    function displayResults(result, audioBuffer) {
      lastResult = result;
      lastAudioBuffer = audioBuffer;

      resultsEl.style.display = 'block';
      cuesListEl.innerHTML = '';

      result.mouthCues.forEach((cue) => {
        const cueEl = document.createElement('div');
        cueEl.className = 'cue';
        cueEl.innerHTML = `
          <span class="cue-time">${cue.start.toFixed(2)}s - ${cue.end.toFixed(2)}s</span>
          <span class="cue-value">${cue.value}</span>
        `;
        cuesListEl.appendChild(cueEl);
      });

      // Auto-play animation
      playAnimation(result.mouthCues, audioBuffer);
    }

    // Play animation synchronized with audio
    function playAnimation(mouthCues, audioBuffer) {
      if (!audioBuffer) return;

      playBtn.disabled = true;
      playBtn.textContent = '‚è∏ Playing';

      const audioContext = new AudioContext();
      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioContext.destination);

      const startTime = audioContext.currentTime;
      source.start(0);
      currentPlayback = source;

      // Animate visemes
      let currentCueIndex = 0;

      function updateViseme() {
        const elapsed = audioContext.currentTime - startTime;

        while (currentCueIndex < mouthCues.length &&
               mouthCues[currentCueIndex].end < elapsed) {
          currentCueIndex++;
        }

        if (currentCueIndex < mouthCues.length) {
          const cue = mouthCues[currentCueIndex];
          setViseme(cue.value);
          requestAnimationFrame(updateViseme);
        } else {
          setViseme('X');
        }
      }

      updateViseme();

      source.onended = () => {
        setViseme('X');
        playBtn.disabled = false;
        playBtn.textContent = '‚ñ∂ Play';
      };
    }

    // Play button - replay the animation
    playBtn.addEventListener('click', () => {
      if (lastResult && lastAudioBuffer) {
        if (currentPlayback) {
          currentPlayback.stop();
        }
        playAnimation(lastResult.mouthCues, lastAudioBuffer);
      }
    });

    // Record audio
    recordBtn.addEventListener('click', async () => {
      try {
        recordBtn.disabled = true;
        loadBtn.disabled = true;
        statusEl.textContent = 'Recording... Speak now!';
        statusEl.className = 'status recording';
        resultsEl.style.display = 'none';
        errorEl.style.display = 'none';

        addLog('=== Starting Recording ===', 'info');
        addLog('Microphone access granted', 'info');
        addLog('Recording 5 seconds...', 'info');

        const { pcm16, audioBuffer } = await recordAudio(5000);

        addLog('Recording stopped', 'info');
        const duration = (pcm16.length / 16000).toFixed(2);
        addLog(`‚úÖ Captured ${pcm16.length} samples (${duration}s)`, 'success');

        await analyze(pcm16, audioBuffer);
      } catch (err) {
        showError('Recording failed: ' + err.message);
        statusEl.textContent = 'Recording failed';
        statusEl.className = 'status';
      } finally {
        recordBtn.disabled = false;
        loadBtn.disabled = false;
      }
    });

    // Load audio file
    loadBtn.addEventListener('click', () => {
      fileInput.click();
    });

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      try {
        recordBtn.disabled = true;
        loadBtn.disabled = true;
        statusEl.textContent = 'Loading audio file...';
        statusEl.className = 'status analyzing';
        resultsEl.style.display = 'none';
        errorEl.style.display = 'none';

        addLog('=== Loading Audio File ===', 'info');
        addLog(`File: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`, 'info');

        const { pcm16, audioBuffer } = await loadAudio(file);

        const duration = (pcm16.length / 16000).toFixed(2);
        addLog(`‚úÖ Decoded: ${pcm16.length} samples (${duration}s at 16kHz)`, 'success');

        await analyze(pcm16, audioBuffer);
      } catch (err) {
        showError('Failed to load audio: ' + err.message);
        statusEl.textContent = 'Failed to load audio';
        statusEl.className = 'status';
      } finally {
        recordBtn.disabled = false;
        loadBtn.disabled = false;
        fileInput.value = '';
      }
    });

    function showError(message) {
      errorEl.textContent = message;
      errorEl.style.display = 'block';
    }

    // Initialize on load
    recordBtn.disabled = true;
    loadBtn.disabled = true;
    init();
  </script>
</body>
</html>
